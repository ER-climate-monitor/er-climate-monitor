---
title: Design
layout: default
---
# Design

## Architecture Overview

The developed system is based on a *client-server* architecture, where the `Frontend` communicates with a centralized `Backend` to interact with the website itself. The Backend in turn can be broken down into smaller parts, as a microservices development approach was adopted. Each of the various microservices represents a subdomain of the entire system, each defining its own *bounded context*. In addition to the various developed microservices, the Backend also includes a main transit component, the API Gateway. All requests coming from the Frontend arrive at the API Gateway, which is then responsible for routing the client's request to a specific service. The identified microservices are as follows:
- **Authentication Service**
- **Notification Service**
- **Detection Service**
- **Sensor Registry Service**

To function, each of the identified microservices requires a database. To meet this need, it was decided to use a NoSQL database like MongoDB. Finally, to enable communication between the various services, REST APIs were used, using JSON as the data type exchanged between various requests.  
The system was developed using microservices in order to increase its scalability and ease of maintenance.

![Architecture Overview](./images/Arch/General%20Architecture.drawio.png)

### Authentication Service

The first microservice we are going to describe is the authentication service. The bounded context it covers concerns the management of various users, both registered and unregistered, and the generation of tokens to verify whether the user is authenticated or not (the authentication function will then intersect with the API Gateway). As previously described, this service has its own database, in which all users belonging to the domain are stored. Two different categories of users can be distinguished: regular users and admins. This difference then reflects on the various functionalities that the system provides.

### Notification Service

The notification system is mainly composed of two components:

- A `MessageBroker`, capable of handling the arrival of events within an event bus sent by the Detection Service ([Detection Service](#detection-service)).
- A `SocketManager`, capable of establishing and managing persistent connections with users who request subscription to a specific event, and thus the relative *routing* based on it.

Regarding *events*, they originate from the sensors themselves and are propagated via the measurement service, which in turn publishes the events through an event bus, in order to maintain asynchronous communication with a *best effort* QoS (as the content of the notifications is not of critical importance). The notification service extracts fundamental information from *Detection* for constructing the notification that will be sent to the client, in particular extracting the *type* of the event, the *sensor name*, and the *query* related to the event: this last one may represent a threshold value, such as the river capacity exceeding 75%, or a simple nominal value like *severe wind gusts*. In this way, notification routing is performed based on the `topic` to which users subscribe. Specifically, the topic is of the form `notifications.<type>.<sensor-name?>.<query?>`, where the sensor name and query can be replaced by wildcards (`#` or `*`), in order to provide coarse to increasingly fine-grained mechanisms regarding the type of notifications a user wants to receive. Regarding these, the connections are persistent to have a *real-time* behavior without the need for polling mechanisms to the server.

Finally, the service has a document-based database containing two types of documents: the first contains information regarding user subscriptions, while the second stores the serialized events sent through the event bus by the detection service. In conclusion, it is possible to dynamically configure the behavior of the `notification-service` upon receiving a new event, through the addition of a `notificationCallback`, i.e., the action that is executed upon arrival of each notification from the event bus. In this way, it is possible to define more articulated mechanisms for sending notifications, such as sending emails, emitting an event via the WebSocket channel, or reporting to other services.

### Detection Service

The Detection Service is responsible for managing and making available the detections coming from the various sensors present in the system. This service provides an interface for storing and retrieving detections and a real-time connection via socket for immediate reception of detections generated by the sensors.

In particular, the detection service provides a series of routes to interact with the system, each allowing different operations on the data regarding detections.

The service allows saving the various detections produced by active sensors, will also allow obtaining the position of all available sensors filtered by type of sensor, and finally it will be possible to obtain a detection history of a specific sensor.

The detection service offers "real-time" communication through the use of a socket connection to allow the sending of detections received by the service to clients who subscribe to receive updates for a single sensor, this communication will be useful for real-time updates of graphs showing the detection values of a single sensor.

### Sensor Registry Service

As described earlier, each microservice refers to a specific bounded context; in particular, the Sensor Registry Service allows interaction with the various sensors installed in the territory. This microservice in particular acts as the main registry, within which all references of the various sensors are maintained, including their IP address and Port. In this way, in case an admin needs to stop a sensor, they would use this service. Also in this case, all various sensors are stored in a database that refers solely and exclusively to this service.

### API Gateway
Finally, the last developed service is the API Gateway, whose task is to collect all client requests and redirect them to the appropriate service. Subsequently, once it receives the response from the queried service, it will return the response to the client. Another of the main functionalities of this system is the authentication service. To do this, this service uses the Authentication Service, which, once it returns a token, the API Gateway stores it in a repository to allow optimized searches to validate the permissions and responsibilities of the user who made the request. The API gateway is developed to be agnostic from every type of technology to use for HTTP communication between the API Gateway and a Generic Service, this was achieved by working heavily with Inheritance and Generics.

## Technologies Used
Various technologies were used to develop this project. Below, they are separated into Frontend and Backend technologies.

### Frontend Technologies
The first technologies we will list concern all the development of the user interface. First of all, we started by choosing the programming language, in this case we relied on `Typescript`, in order to obtain the advantages of `Javascript` and the safety of defining variable types thanks to `Typescript`. Once the programming language was chosen, we moved on to selecting the development framework; among the various possibilities we chose to use `Vue.js`, which through the `Composition API` and ease of supporting `Typescript` allowed us to develop interfaces easily and quickly. Along with this framework, several libraries were used to enable interaction between client and server such as the `Axios` library and the `Socket.io` library to allow communication via **socket**. Subsequently, as a CSS framework, we chose `Tailwind`, since it can be adopted in `Vue.js` in an intuitive way. Once all these dependencies were defined, we also introduced a set of functionalities that allow us to maintain high code quality. For example, as described in the non-functional requirements, one of the main qualities that our interfaces must meet concerns accessibility; to verify that the pages of our website are always accessible, we used the `eslit-plugin-vuejs-accessibility` library, which combined with the `linter` allowed us to correct and make the pages accessible. In addition, to ensure that component definitions are error-free, we used the `eslit` library.

### Backend Technologies

As for the entire backend side, we chose to use `NodeJS` with the use of the `Express` library. All code was written using `Typescript`, in order to maintain type safety and code extensibility. In some of the implemented microservices, the `Socket.io` library is used to create and maintain communications through the WebSocket protocol. As mentioned earlier, each microservice has its own `Mongodb` NoSQL database, used together with the `Mongoose` library for the definition and interaction with various documents. Finally, each of the various microservices was tested using specific libraries for creating tests, including: `Mocha`, `Supertest`, and `Jest`. Each test uses a dedicated database to avoid interfering with production databases. Below, some technologies referring only to specific implemented services will be specified.

#### Authentication Service

The authentication service, as previously described, also handles the creation and validation of Tokens. To perform this task, the `jwt` and `jwt-decode` libraries are used.

#### API Gateway

Within the API Gateway, `Redis` is used as a repository in which to store the tokens received from the Authentication Service. Moreover, to route client requests to other services, the `Axios` library is used.

#### Notification Service

The notification service, to maintain asynchronous communication with the event producer (detection service), uses a RabbitMQ broker for receiving messages from the latter. Their communication takes place through a single *exchange*, while the routing of the various events takes place through the appropriate *routing key*, composed similarly to the *topic*, i.e., `<type>.<sensor-name>.<query>`, with the difference that all parameters are mandatory. In this way, it is possible to create a dynamic number of queues based on the type of sensors, their name, or the queries they expose, since the queues are generated based on the *routing key* specified in the event. Thanks to this mechanism, the entire notification service is agnostic with respect to the diversity of the sensors, with the limitation that the *routing key* is always in the required format.

## Sensor Overview

Another necessary part that we had to develop, concerned the sensor. This object, is the agent that sends detections (by using the Its sensors) towards our services. Each sensor is scheduled for perioding detections, and every time It senses new data, It will send them to the Detection Service. The definition of a single sensor, can be done by using an internal DSL that we made, in this way the creation of a sensor is fast and simple.

### Sensor Technologies

We choose Python3 as the programming language for implementing a sensor, in this way we were capable of creating a complex architecture easily. The sensor, in order to be able to receive messages from the outside, It is implemented using *FastApi*, by doing so the sensor is a http server, that exposes some routes for interacting with the outside world and for making the interaction with the sensor accessible from remote. We also used *apscheduler* for automatizing the scheduling of a task in specific intervals of time, and finally we used the library *uvicorn* for starting the http server.

## DSL Overview

The last important aspect to discuss is our Domain Specific Language (DSL). We introduced an internal DSL to assist users in creating their own sensors easily by providing a human-readable language. This DSL guides users through the definition of sensor parameters and automatically generates a corresponding Python 3 file that represents the configured sensor. Here it is an example of our language: 

```yaml
{
    name "Diga di Ridracoli"
    infos {
        description "Sensore idrometrico diga di Ridracoli"
        type idro_level
        queries [
            - threshold "soglia90%" > "570"
            - threshold "soglia100%" > "575"
        ]
    }

    network {
        port 1926
        ip "10.100.101.241"
    }

    gateway {
        url "api-gateway-17633123551.europe-west8.run.app"
        port 8080
        registerRoute "/register"
        shutdownRoute "/shutdown"
        detectionRoute "/detection"
        alertRoute "/alert"
    }

    registry {
        registryUrl "sensor-registry-17633123551.europe-west8.run.app/v0/sensor"
        key "secretKey"
    }

    cronjob {
        from friday to saturday at "12":"00"
    }
}
```

The DSL significantly streamlines the process of creating sensors for system administrators. It enforces strict typing on all parameters, ensuring that every sensor is defined with complete accuracy. For instance, it validates that network.port values fall within the allowed range [0, 65,535] and that network.ip entries are valid IP addresses. This built-in validation reduces errors and improves reliability across the system. Additionally, the DSL simplifies cron job scheduling by allowing administrators to define schedules using a human-readable syntax, which is then automatically converted into the appropriate Python-compatible format.

### DSL Technologies

The Domain Specific Language was created using XText with Java, and also in order to improve the usability of the system, the DSL project is also dockerized. In this way every admin can simply run the project with this command:

```bash
docker run -p 8080:8080 --name deleteme sfuri/er-climate-monitor-dsl-editor:1.0.4
```

Using this service, the administrator can define a sensor and check if there are no errors in its definition, after doing so the admin has to create a file "<my-sensor-config>.uanciutri" that will be given as input to the sensor generator software for the real sensor creation.

---

<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.9em;">
  <a href="/er-climate-monitor/2-analysis.html">&laquo; Previous</a>
  <a href="/er-climate-monitor/index.html" style="text-align: center;">Home</a>
  <a href="/er-climate-monitor/4-devops.html">Next &raquo;</a>
</div>

